<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>(*&#xD;
***********************************&#xD;
				SysReset V4&#xD;
***********************************&#xD;
GP - Octobre 2013&#xD;
**********************************&#xD;
Objet : &#xD;
- Fonction permettant d'acquiter les défauts du systéme quelquesoit leur provenance&#xD;
Le bloc intégre maintenant l'acquitement des axes et des groupes d'axes pour conserver l'exclusivité des blocs motion&#xD;
&#xD;
Juillet 2015 : GP :  &#xD;
	* Ajout du redémarrage du G7 sur une demande d'acquitement&#xD;
	* Retrait des cartes CJB pour être compatible NX7&#xD;
	&#xD;
Decembre 2016 : GP :	Détecttion du nombre d'axes logiques et du nombre de groupe logique pour NX7 et NX1P&#xD;
***********************************&#xD;
*)&#xD;
&#xD;
IF NOT Init THEN&#xD;
	Nb_Axes := SizeOfAry(_MC_AX);&#xD;
	Nb_Groupes := SizeOfAry(_MC_GRP);&#xD;
	Init := TRUE;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
Frm_Acquit(CLK:=Reset);&#xD;
IF Frm_Acquit.Q THEN &#xD;
	State:=0;&#xD;
END_IF;&#xD;
&#xD;
CASE State OF &#xD;
	&#xD;
0 : 	(* Attente demande d'acquitement *)&#xD;
&#xD;
	iFB_ResetEC (Execute := FALSE);&#xD;
	iFB_ResetMC (Execute := FALSE);&#xD;
	iFB_ResetPlc (Execute := FALSE);&#xD;
	&#xD;
	Axis_Reset := FALSE;&#xD;
	Group_Reset := FALSE;&#xD;
	&#xD;
	IF Reset THEN&#xD;
		State := 10;&#xD;
	END_IF;&#xD;
		&#xD;
10: (* Parcours de tous les axes pour les acquitter *)	&#xD;
	 &#xD;
	 Index := 0;&#xD;
	 State := 20;&#xD;
	 &#xD;
20: (* Test si l'axe est utilisé *)&#xD;
 &#xD;
	 IF  _MC_AX[Index].Cfg.AxEnable = _mcUsedAxis THEN&#xD;
		 Axis_Reset := TRUE;&#xD;
		 State := 30;&#xD;
	 ELSE&#xD;
		 State := 40;&#xD;
	 END_IF;&#xD;
	 &#xD;
30: (* Attente que l'axe soit réseter *)&#xD;
	&#xD;
	IF iFB_MC_Reset.Done THEN&#xD;
		Axis_Reset := FALSE;&#xD;
		State := 40;&#xD;
	END_IF;&#xD;
	&#xD;
40 : (* Incrémentation de l'index *)&#xD;
&#xD;
	Inc(Index);&#xD;
	&#xD;
	IF Index &lt; Nb_Axes THEN&#xD;
		State := 20;&#xD;
	ELSE&#xD;
		State := 50;&#xD;
	END_IF;&#xD;
	&#xD;
50: (* Parcours de tous les groupes pour les acquitter *)	&#xD;
	 &#xD;
	 Index := 0;&#xD;
	 State := 60;&#xD;
	 &#xD;
60: (* Test si l'axe est utilisé *)&#xD;
	 &#xD;
	 IF _MC_GRP[Index].Cfg.GrpEnable = _mcUsedGroup THEN&#xD;
		Group_Reset := TRUE;&#xD;
		 State := 70;&#xD;
	 ELSE&#xD;
	 	State := 80;&#xD;
	 END_IF;&#xD;
	 &#xD;
70: (* Attente que le groupe soit réseter *)&#xD;
	&#xD;
	IF iFB_MC_ResetGroup.Done THEN&#xD;
		Group_Reset := FALSE;&#xD;
		State := 80;&#xD;
	END_IF;&#xD;
	&#xD;
80 : (* Incrémentation de l'index *)&#xD;
&#xD;
	Inc(Index);&#xD;
	&#xD;
	IF Index &lt; Nb_Groupes THEN&#xD;
		State := 60;&#xD;
	ELSE&#xD;
		State := 90;&#xD;
	END_IF;&#xD;
	&#xD;
90 : (* Acquitement du Motion Controler *)&#xD;
&#xD;
	iFB_ResetMC (Execute := TRUE);&#xD;
&#xD;
	IF iFB_ResetMC.Done THEN&#xD;
		iFB_ResetMC (Execute := FALSE);&#xD;
		State := 100;&#xD;
	END_IF;&#xD;
&#xD;
100 : (* Acquitement des alarmes utilisateurs *)&#xD;
	&#xD;
	IF GetAlarm() THEN&#xD;
		ResetAlarm(0);&#xD;
	END_IF;&#xD;
	&#xD;
	State := 110;&#xD;
	&#xD;
110 : (* Acquitement du maitre Ethercat *)&#xD;
	&#xD;
	iFB_ResetEC (Execute := TRUE);&#xD;
&#xD;
	IF iFB_ResetEC.Done THEN&#xD;
		iFB_ResetEC (Execute := FALSE);&#xD;
		State := 120;&#xD;
	END_IF;	&#xD;
	&#xD;
120 : (* Reset de la CPU *)&#xD;
&#xD;
	iFB_ResetPlc (Execute := TRUE);&#xD;
	&#xD;
	IF iFB_ResetPlc.Done THEN&#xD;
		iFB_ResetPlc (Execute := FALSE);&#xD;
		State := 0;&#xD;
	END_IF;&#xD;
	&#xD;
END_CASE;&#xD;
&#xD;
(* Gestion des FBs *)&#xD;
 iFB_MC_Reset(Axis:= _MC_AX[Index], Execute:= Axis_Reset);&#xD;
 iFB_MC_ResetGroup(AxesGroup:= _MC_GRP[Index], Execute:= Group_Reset);</Text></StructuredTextModel>