<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>(*&#xD;
*******************************************&#xD;
*					OEEF - F.SIMON					*&#xD;
*******************************************&#xD;
*)&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*	 		Bits fronts de statuts : RAZ			*&#xD;
*******************************************&#xD;
*)&#xD;
IF IO.Flags.Done THEN&#xD;
	IO.Flags.Done:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
IF IO.Move.T_InDone THEN&#xD;
	IO.Move.T_InDone:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
IF IO.Move.T_OutDone THEN&#xD;
	IO.Move.T_OutDone:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
IF IO.Track.T_InDone THEN&#xD;
	IO.Track.T_InDone:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
IF IO.Flags.MasterModulo THEN&#xD;
	IO.Flags.MasterModulo:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*						Axe maître						*&#xD;
*******************************************&#xD;
*)&#xD;
// Type&#xD;
IF IO.MasterPosition.NotFrom_sAXIS_REF THEN&#xD;
	MasterPosition:=IO.MasterPosition.ExternalVariable;&#xD;
ELSE&#xD;
	MasterPosition:=IO.MasterAxis.Act.Pos;&#xD;
END_IF;&#xD;
&#xD;
// Offset&#xD;
MasterModulo:=(ReadAxisMasterPParam.PosCount.ModuloMaxPosVal-ReadAxisMasterPParam.PosCount.ModuloMinPosVal);&#xD;
IF IO.Cam.MasterOffset&lt;0 THEN&#xD;
	MasterPosition:=ModReal(MasterPosition-IO.Cam.MasterOffset,MasterModulo);&#xD;
ELSE&#xD;
	MasterPosition:=ModReal(MasterPosition+(MasterModulo-IO.Cam.MasterOffset),MasterModulo);&#xD;
END_IF;&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*		Commande de tracking active		*&#xD;
*******************************************&#xD;
*)&#xD;
// Etire le polynôme : recalcule la distance à parcourir depuis l'origine du tracking tant que l'on n'est pas synchronisé&#xD;
IF TypeOfCmd=Track AND NOT IO.Flags.Synchronised THEN&#xD;
	TargetDist:=IO.Track.TrackPos-MemPosAxis; &#xD;
END_IF;&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*			Commande 	de came					*&#xD;
*			ou de warmstart active 				*&#xD;
*******************************************&#xD;
*)&#xD;
IF TypeOfCmd=Cam OR TypeOfCmd=WarmStart THEN&#xD;
	// Nombre de noeuds du profil&#xD;
	NodesNb:=1;&#xD;
	WHILE IO.Cam.Profile[CurrentProfile].Node[NodesNb].MasterAxisPos&lt;&gt;0&#xD;
		DO&#xD;
		NodesNb:=NodesNb+1;&#xD;
	END_WHILE;&#xD;
&#xD;
	// Nombre de segments&#xD;
	SegmentsNb:=NodesNb-1;&#xD;
&#xD;
	// Application du nouveau profil au passage du modulo du master en cas de changement à la volée&#xD;
	IF MasterPosition&lt;&gt;memPosition THEN&#xD;
		IF abs(memPosition-MasterPosition)&gt;abs(MasterModulo)/2 THEN&#xD;
			CurrentProfile:=IO.Cam.ProfileToApply;&#xD;
			IO.Flags.MasterModulo:=TRUE;&#xD;
		END_IF;&#xD;
		memPosition:=MasterPosition;&#xD;
	END_IF;	&#xD;
&#xD;
	// Evolution du segment en cours&#xD;
	FOR ScannedSeg:=0 TO SegmentsNb-1 DO&#xD;
		IF MasterPosition&gt;=IO.Cam.Profile[CurrentProfile].Node[ScannedSeg].MasterAxisPos AND MasterPosition&lt;IO.Cam.Profile[CurrentProfile].Node[ScannedSeg+1].MasterAxisPos THEN&#xD;
			CurrentSegment:=ScannedSeg;&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
&#xD;
	// Paramètres du polynôme dans le segment en cours&#xD;
	X0:=IO.Cam.Profile[CurrentProfile].Node[CurrentSegment].MasterAxisPos;										// Abscisse de début&#xD;
	&#xD;
	IF SlaveCountMode=_mcCountModeRotary AND																				// Ordonnée de début&#xD;
		IO.Cam.Profile[CurrentProfile].Node[CurrentSegment].SlaveAxisPos=SlaveModulo THEN&#xD;
		Y0:=IO.Cam.SlaveOffset+SlaveMinPos;&#xD;
	ELSE&#xD;
		Y0:=IO.Cam.SlaveOffset+IO.Cam.Profile[CurrentProfile].Node[CurrentSegment].SlaveAxisPos;&#xD;
	END_IF;&#xD;
	&#xD;
	X1:=IO.Cam.Profile[CurrentProfile].Node[CurrentSegment+1].MasterAxisPos;									// Abscisse de fin&#xD;
	&#xD;
	IF 	SlaveCountMode=_mcCountModeRotary AND																				// Ordonnée de fin&#xD;
		IO.Cam.Profile[CurrentProfile].Node[CurrentSegment+1].SlaveAxisPos=SlaveModulo THEN&#xD;
		Y1:=IO.Cam.SlaveOffset+SlaveMaxPos;&#xD;
	ELSE&#xD;
		Y1:=IO.Cam.SlaveOffset+IO.Cam.Profile[CurrentProfile].Node[CurrentSegment+1].SlaveAxisPos;&#xD;
	END_IF;&#xD;
	&#xD;
	MasterDist:=X1-X0;																																	// Distance de la composante X&#xD;
	TargetDist:=Y1-Y0;																																	// Distance de la composante Y&#xD;
	Offset:=Y0;																																				// Offset de départ&#xD;
&#xD;
	// Distance parcourue par le maître&#xD;
	MasterDistDone:=MasterPosition-X0;&#xD;
 &#xD;
	SegmentPolyType:=IO.Cam.Profile[CurrentProfile].Node[CurrentSegment+1].CurveTypeBefore;			// Type de profil&#xD;
	&#xD;
	// Pente de raccordement de la vitesse de début de segment&#xD;
	IF IO.Cam.Profile[CurrentProfile].Node[CurrentSegment+1].StartSlopeCalc=Manual THEN&#xD;
		v0CamSetting:=IO.Cam.Profile[CurrentProfile].Node[CurrentSegment+1].StartingSlope;&#xD;
	ELSE&#xD;
		// Noeuds des segments à raccorder&#xD;
		IF CurrentSegment-1&lt;0 THEN&#xD;
			NodeA_starting:=NodesNb-1; // Dernier noeud&#xD;
		ELSE&#xD;
			NodeA_starting:=CurrentSegment-1;&#xD;
		END_IF;&#xD;
		NodeB_starting:=CurrentSegment;&#xD;
		NodeC_starting:=CurrentSegment+1;&#xD;
		// dx et dy des segments&#xD;
		dx1_starting:=IO.Cam.Profile[CurrentProfile].Node[NodeB_starting].MasterAxisPos-IO.Cam.Profile[CurrentProfile].Node[NodeA_starting].MasterAxisPos;&#xD;
		dy1_starting:=IO.Cam.Profile[CurrentProfile].Node[NodeB_starting].SlaveAxisPos-IO.Cam.Profile[CurrentProfile].Node[NodeA_starting].SlaveAxisPos;&#xD;
		dx2_starting:=IO.Cam.Profile[CurrentProfile].Node[NodeC_starting].MasterAxisPos-IO.Cam.Profile[CurrentProfile].Node[NodeB_starting].MasterAxisPos;&#xD;
		dy2_starting:=IO.Cam.Profile[CurrentProfile].Node[NodeC_starting].SlaveAxisPos-IO.Cam.Profile[CurrentProfile].Node[NodeB_starting].SlaveAxisPos;&#xD;
		// Pente&#xD;
		v0CamSetting:=(dy1_starting*dx2_starting)/(dx1_starting*dy2_starting);&#xD;
	END_IF;&#xD;
	&#xD;
	// Pente de raccordement de la vitesse de fin de segment&#xD;
	IF IO.Cam.Profile[CurrentProfile].Node[CurrentSegment+1].EndSlopeCalc=Manual THEN&#xD;
		v1CamSetting:=IO.Cam.Profile[CurrentProfile].Node[CurrentSegment+1].EndingSlope;&#xD;
	ELSE&#xD;
		// Noeuds des segments à raccorder&#xD;
		NodeA_ending:=CurrentSegment;&#xD;
		NodeB_ending:=CurrentSegment+1;&#xD;
		IF CurrentSegment+2&gt;NodesNb-1 THEN&#xD;
			NodeC_ending:=0; // Premier noeud&#xD;
		ELSE&#xD;
			NodeC_ending:=CurrentSegment+2;&#xD;
		END_IF;&#xD;
		// dx et dy des segments&#xD;
		dx1_ending:=IO.Cam.Profile[CurrentProfile].Node[NodeB_ending].MasterAxisPos-IO.Cam.Profile[CurrentProfile].Node[NodeA_ending].MasterAxisPos;;&#xD;
		dy1_ending:=IO.Cam.Profile[CurrentProfile].Node[NodeB_ending].SlaveAxisPos-IO.Cam.Profile[CurrentProfile].Node[NodeA_ending].SlaveAxisPos;&#xD;
		dx2_ending:=IO.Cam.Profile[CurrentProfile].Node[NodeC_ending].MasterAxisPos-IO.Cam.Profile[CurrentProfile].Node[NodeB_ending].MasterAxisPos;&#xD;
		dy2_ending:=IO.Cam.Profile[CurrentProfile].Node[NodeC_ending].SlaveAxisPos-IO.Cam.Profile[CurrentProfile].Node[NodeB_ending].SlaveAxisPos;&#xD;
		// Pente&#xD;
		v1CamSetting:=(dy2_ending*dx1_ending)/(dx2_ending*dy1_ending);&#xD;
	END_IF;&#xD;
	&#xD;
	//a0CamSetting:=?																																// Pente de raccordement de l'accélération de début de segment&#xD;
	//a1CamSetting:=?																																// Pente de raccordement de l'accélération de fin de segment&#xD;
&#xD;
	// Arrêt du calcul de la position de l'esclave pour le WarmStart&#xD;
	IF WarmStartCalculation THEN&#xD;
		WarmStartCalculation:=FALSE;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*						Générateur						*&#xD;
*******************************************&#xD;
*)&#xD;
CASE Phase OF&#xD;
	&#xD;
	-1 : // ERREUR&#xD;
	&#xD;
		// Bits rémanents de statuts et de commandes : RAZ&#xD;
		WarmStartCalculation:=FALSE;&#xD;
		FBi_ReadAxisMasterParam.Execute:=FALSE;&#xD;
		FBi_ReadAxisSlaveParam.Execute:=FALSE;&#xD;
		FBi_SyncMov.Execute:=FALSE;&#xD;
		FBi_SyncStop.Execute:=FALSE;&#xD;
		FBi_SyncMovVel.Execute:=FALSE;&#xD;
		IO.Flags.Synchronised:=FALSE;&#xD;
	&#xD;
		// Acquittement&#xD;
		IF Reset THEN&#xD;
			CamSettingError:=FALSE;&#xD;
			Phase:=0;&#xD;
		END_IF;&#xD;
	&#xD;
	0 : // COMMANDES&#xD;
&#xD;
		IF NOT Error THEN&#xD;
				Edge1(IO.Move.Exe,UpExecMvt);															// Commande de mouvement polynômial&#xD;
				Edge2(IO.Track.Exe,UpExecTrack);														// Commande de tracking&#xD;
				Edge3(IO.Track.Cancel,UpCancelTrack);												// Commande d'annulation de tracking&#xD;
				Edge4(IO.Cam.Exe,UpExecCam);															// Commande de mise en came&#xD;
				Edge5(IO.Cam.WarmStartSlavePosRequest,UpWarmStartPosReq);		// Commande de calcul de la position de l'esclave pour le WarmStart&#xD;
&#xD;
				// Commande de mouvement polynômial&#xD;
				IF UpExecMvt AND IO.Move.Tim&gt;0 THEN&#xD;
					TypeOfCmd:=PolyMvt;&#xD;
					Gen:=Axis.Act.Pos;&#xD;
					&#xD;
					// Nombre de cycles cpu nécessaires pour le mouvement&#xD;
					TicksQ:=fTicksQCalc(IO.Move.Tim);&#xD;
					Tick:=0;&#xD;
					&#xD;
					// Calcul de la distance à effectuer&#xD;
					IF IO.Move.Mode=Absolute THEN&#xD;
						TargetDist:=IO.Move.Pos-Axis.Act.Pos;&#xD;
					ELSIF IO.Move.Mode=Relative THEN&#xD;
						TargetDist:=IO.Move.Dist;&#xD;
					END_IF;&#xD;
					&#xD;
					Phase:=10;&#xD;
				END_IF;&#xD;
				&#xD;
				// Commande de tracking&#xD;
				IF UpExecTrack AND IO.Track.Tim&gt;0 THEN&#xD;
					TypeOfCmd:=Track;&#xD;
					Gen:=Axis.Act.Pos;&#xD;
					&#xD;
					// Le début du tracking utilise une fonction polynômiale&#xD;
					IO.Move.Tim:=IO.Track.Tim;&#xD;
					// Nombre de cycles cpu nécessaires pour le mouvement&#xD;
					TicksQ:=fTicksQCalc(IO.Track.Tim);&#xD;
					Tick:=0;&#xD;
					// Sauvegarde la position de l'axe&#xD;
					MemPosAxis:=Axis.Act.Pos;&#xD;
					// Calcul de la distance initiale à effectuer&#xD;
					TargetDist:=IO.Track.TrackPos-MemPosAxis;&#xD;
					Phase:=10;&#xD;
				END_IF;&#xD;
				&#xD;
				// Commande d'annulation du tracking&#xD;
				IF UpCancelTrack THEN&#xD;
					TypeOfCmd:=CancelTrack;&#xD;
					&#xD;
					// Sauvegarde la vitesse de l'axe&#xD;
					MemSpeedAxis:=Axis.Act.Vel;&#xD;
					Phase:=30;&#xD;
				END_IF;&#xD;
&#xD;
				// Commande de came&#xD;
				IF UpExecCam THEN&#xD;
					TypeOfCmd:=Cam;&#xD;
					Gen:=Axis.Act.Pos;&#xD;
					&#xD;
					ProfilesNbMax:=10;&#xD;
					NodesNbMax:=10;&#xD;
					Phase:=5;&#xD;
				END_IF;&#xD;
&#xD;
				// Annulation de la commande de came : Traitée en Phase 20 pendant son exécution&#xD;
&#xD;
				// Commande de calcul de la position de l'esclave pour le WarmStart&#xD;
				IF UpWarmStartPosReq THEN&#xD;
					TypeOfCmd:=WarmStart;&#xD;
					ProfilesNbMax:=10;&#xD;
					NodesNbMax:=10;&#xD;
					WarmStartCalculation:=TRUE;&#xD;
					Phase:=5;&#xD;
				END_IF;&#xD;
		END_IF;&#xD;
&#xD;
&#xD;
	5 : // INIT : lecture des paramètres des axes&#xD;
&#xD;
		FBi_ReadAxisMasterParam.Execute:=TRUE;&#xD;
		FBi_ReadAxisSlaveParam.Execute:=TRUE;&#xD;
		&#xD;
		IF FBi_ReadAxisMasterParam.Done AND FBi_ReadAxisSlaveParam.Done THEN&#xD;
			ReadAxisDelay(In:=TRUE, PT:=T#10ms); // On s'assure que les paramètres sont propagés dans tout le FB&#xD;
			IF ReadAxisDelay.Q THEN&#xD;
				ReadAxisDelay(In:=FALSE);&#xD;
				FBi_ReadAxisMasterParam.Execute:=FALSE;&#xD;
				FBi_ReadAxisSlaveParam.Execute:=FALSE;&#xD;
				Phase:=10;&#xD;
			END_IF;&#xD;
		ELSIF FBi_ReadAxisMasterParam.Error OR FBi_ReadAxisSlaveParam.Error THEN&#xD;
			ReadAxisDelay(In:=FALSE);&#xD;
			FBi_ReadAxisMasterParam.Execute:=FALSE;&#xD;
			FBi_ReadAxisSlaveParam.Execute:=FALSE;&#xD;
			Phase:=-1;&#xD;
		END_IF;&#xD;
&#xD;
&#xD;
	10 : // INIT : flags, offset&#xD;
	&#xD;
		// Exe&#xD;
		FBi_SyncMov.Execute:=FALSE;&#xD;
	&#xD;
		// Distance nulle : on ne bouge pas&#xD;
		IF abs(TargetDist)=0 THEN&#xD;
			IO.Flags.Done:=TRUE;&#xD;
			Phase:=0;&#xD;
		END_IF;&#xD;
		&#xD;
		// Offsets de départ	&#xD;
		IF TypeOfCmd&lt;&gt;Cam AND TypeOfCmd&lt;&gt;WarmStart THEN&#xD;
			// Débute le mouvement à partir de la position actuelle&#xD;
			Offset:=Axis.Act.Pos;&#xD;
			Phase:=15;&#xD;
		ELSIF TypeOfCmd=Cam THEN&#xD;
			// Débute le mouvement à partir de Y0&#xD;
			Offset:=Y0;&#xD;
			Phase:=15;&#xD;
		ELSIF TypeOfCmd=WarmStart THEN&#xD;
			// Débute le mouvement à partir de Y0 et n'active pas la fonction de positionnement cyclique&#xD;
			Offset:=Y0;&#xD;
			Phase:=20;&#xD;
		END_IF;&#xD;
		&#xD;
		&#xD;
	15 : // INIT : activation de la fonction de positionnement cyclique&#xD;
	&#xD;
		FBi_SyncMov.Execute:=TRUE;&#xD;
		&#xD;
		IF FBi_SyncMov.Active THEN&#xD;
			FBi_SyncMov.Execute:=FALSE;&#xD;
			Phase:=20;&#xD;
		ELSIF FBi_SyncMov.Error THEN&#xD;
			FBi_SyncMov.Execute:=FALSE;&#xD;
			Phase:=-1;&#xD;
		END_IF;&#xD;
&#xD;
&#xD;
	20 : // EXECUTION DU PROFIL&#xD;
&#xD;
		// Flags&#xD;
		IF TypeOfCmd=Cam THEN&#xD;
			IO.Flags.Synchronised:=TRUE;		// En came&#xD;
		END_IF;&#xD;
&#xD;
		// Evolution de x&#xD;
		IF TypeOfCmd=PolyMvt OR TypeOfCmd=Track THEN&#xD;
			// En fonction du temps dans l'intervalle [0 ; 1] (hors came)&#xD;
			x:=LIMIT(0.0,(1.0/LINT_TO_LREAL(TicksQ)*LINT_TO_LREAL(Tick)),1.0);&#xD;
		ELSIF TypeOfCmd=Cam OR TypeOfCmd=WarmStart THEN&#xD;
			// En fonction de la distance parcourue par le maître dans l'intervalle [0 ; 1] (En came)&#xD;
			x:=LIMIT(0.0,((1.0/MasterDist)*MasterDistDone),1.0);&#xD;
		END_IF;&#xD;
		&#xD;
		// Limites du domaine atteintes à 0,1 % et 99,9 % du parcours pour compenser les erreurs d'arrondis&#xD;
		IF x&lt;0.001 THEN&#xD;
			x:=0;&#xD;
		ELSIF x&gt;0.999 THEN&#xD;
			x:=1;&#xD;
		END_IF;&#xD;
		&#xD;
		// Vitesses initiale et finale des polynômes 3 et 5&#xD;
		IF TypeOfCmd=PolyMvt THEN&#xD;
			 // Fixées à zéro pour un mouvement polynômial&#xD;
			v0:=0.0;&#xD;
			v1:=0.0;&#xD;
		ELSIF TypeOfCmd=Track THEN&#xD;
			// v1 en continuité avec celle du maître lors d'un tracking : elle est convertie dans l'intervalle [0;1] du polynôme EN COURS&#xD;
			v0:=0.0;&#xD;
			v1:=(1/(TargetDist/IO.Move.Tim))*IO.MasterAxis.Act.Vel;&#xD;
		ELSIF TypeOfCmd=Cam OR TypeOfCmd=WarmStart THEN&#xD;
			// Imposées par paramétrage de la came&#xD;
			v0:=v0CamSetting;&#xD;
			v1:=v1CamSetting;&#xD;
		END_IF;&#xD;
		&#xD;
		// Accélérations initiale et finale du polynôme 5&#xD;
		IF TypeOfCmd=PolyMvt THEN&#xD;
			a0:=IO.Move.Accel;&#xD;
			a1:=IO.Move.Decel;&#xD;
		ELSIF TypeOfCmd=Cam OR TypeOfCmd=WarmStart THEN&#xD;
			a0:=a0CamSetting;&#xD;
			a1:=a1CamSetting;&#xD;
		END_IF;&#xD;
		&#xD;
		// Polynôme 5&#xD;
		IF TypeOfCmd=PolyMvt AND IO.Move.PolyType=Poly5&#xD;
			OR&#xD;
			(TypeOfCmd=Cam OR TypeOfCmd=WarmStart) AND SegmentPolyType=Poly5&#xD;
			THEN&#xD;
			Gen:=fPoly5(v0, v1, a0, a1, x, Offset, TargetDist);&#xD;
		END_IF;&#xD;
&#xD;
		// Polynôme 3&#xD;
		IF TypeOfCmd=PolyMvt AND IO.Move.PolyType=Poly3 &#xD;
			OR&#xD;
			TypeOfCmd=Track &#xD;
			OR&#xD;
			(TypeOfCmd=Cam OR TypeOfCmd=WarmStart) AND SegmentPolyType=Poly3&#xD;
			THEN&#xD;
			Gen:=fPoly3(v0, v1, x, Offset, TargetDist);&#xD;
		END_IF;&#xD;
&#xD;
		// Straight&#xD;
		IF TypeOfCmd=PolyMvt AND IO.Move.PolyType=Straight &#xD;
			OR&#xD;
			(TypeOfCmd=Cam OR TypeOfCmd=WarmStart) AND SegmentPolyType=Straight&#xD;
			THEN&#xD;
			Gen:=fStraight(x, Offset, TargetDist);&#xD;
		END_IF;&#xD;
&#xD;
		// Evolution du temps (hors came)&#xD;
		IF TypeOfCmd=PolyMvt OR TypeOfCmd=Track THEN&#xD;
			IF Tick&lt;TicksQ THEN&#xD;
				Inc(Tick);&#xD;
	 		// Fin du polynome dans le cas d'une commande de type tracking&#xD;
			ELSIF TypeOfCmd=Track THEN&#xD;
				IO.Flags.Synchronised:=TRUE;&#xD;
				IO.Flags.Done:=TRUE;&#xD;
				Phase:=0;	&#xD;
		 	// Fin du polynome dans le cas d'une commande de mouvement polynômial&#xD;
			ELSIF TypeOfCmd=PolyMvt THEN&#xD;
				Phase:=25;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		&#xD;
		// Evolution du maître (en came)&#xD;
		IF TypeOfCmd=Cam THEN			&#xD;
			// Annulation de came&#xD;
			Edge6(IO.Cam.Cancel,UpCancelCam);	&#xD;
			IF UpCancelCam THEN&#xD;
				IO.Flags.Synchronised:=FALSE;&#xD;
				// Sauvegarde la vitesse de l'axe&#xD;
				MemSpeedAxis:=Axis.Act.Vel;&#xD;
				Phase:=30;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		&#xD;
		// Calcul de la position de l'esclave pour le WarmStart&#xD;
		IF TypeOfCmd=WarmStart THEN&#xD;
			// Le calcul est terminé&#xD;
			IO.Cam.WarmStartSlavePos:=Gen;&#xD;
			IF NOT WarmStartCalculation THEN&#xD;
				IO.Flags.Done:=TRUE;&#xD;
				Phase:=0;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		&#xD;
		&#xD;
	25 : // DECONNEXION&#xD;
	&#xD;
		FBi_SyncStop.Execute:=TRUE;&#xD;
&#xD;
		IF FBi_SyncStop.Done THEN&#xD;
			FBi_SyncStop.Execute:=FALSE;			&#xD;
			IO.Flags.Done:=TRUE;&#xD;
			Phase:=0;&#xD;
		ELSIF FBi_SyncStop.Error THEN&#xD;
			FBi_SyncStop.Execute:=FALSE;&#xD;
			Phase:=-1;			&#xD;
		END_IF;&#xD;
	&#xD;
	&#xD;
	30 : // DECELERATION LINEAIRE&#xD;
	&#xD;
		// Mode CSV à la dernière vitesse connue&#xD;
		FBi_SyncMovVel.Velocity:=MemSpeedAxis;&#xD;
		FBi_SyncMovVel.Execute:=TRUE;&#xD;
		&#xD;
		IF FBi_SyncMovVel.Busy THEN&#xD;
			IO.Flags.Synchronised:=FALSE;&#xD;
			FBi_SyncMovVel.Execute:=FALSE;&#xD;
			// Taux de décélération&#xD;
			IF TypeOfCmd=Track THEN&#xD;
				// Test également possible : IF var &lt;&gt; var = TRUE =&gt; Nan (Non a numeric)&#xD;
				CheckReal(MemSpeedAxis/IO.Track.TimStop,Nan,PosInfinite,NegInfinite);&#xD;
				IF Nan OR PosInfinite OR NegInfinite THEN&#xD;
					FBi_SyncStop.Deceleration:=0.0;&#xD;
				ELSE&#xD;
					FBi_SyncStop.Deceleration:=ABS(MemSpeedAxis/IO.Track.TimStop);&#xD;
				END_IF;&#xD;
			ELSIF TypeOfCmd=Cam THEN&#xD;
 				// ATTENTION : l'axe continue à tourner en CSV (hors came) pendant le temps TimStop&#xD;
				// Vérifier que ce soit mécaniquement possible. Régler un temps court&#xD;
				CheckReal(MemSpeedAxis/IO.Cam.TimStop,Nan,PosInfinite,NegInfinite);&#xD;
				IF Nan OR PosInfinite OR NegInfinite THEN&#xD;
					FBi_SyncStop.Deceleration:=0.0;&#xD;
				ELSE&#xD;
					FBi_SyncStop.Deceleration:=ABS(MemSpeedAxis/IO.Cam.TimStop);&#xD;
				END_IF;&#xD;
			END_IF;&#xD;
			Phase:=25;&#xD;
		ELSIF FBi_SyncMovVel.Error THEN&#xD;
			FBi_SyncMovVel.Execute:=FALSE;&#xD;
			Phase:=-1;			&#xD;
		END_IF;&#xD;
	&#xD;
END_CASE;&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*						Axe esclave						*&#xD;
*******************************************&#xD;
*)&#xD;
SlaveMinPos:=ReadAxisSlavePParam.PosCount.ModuloMinPosVal;&#xD;
SlaveMaxPos:=ReadAxisSlavePParam.PosCount.ModuloMaxPosVal;&#xD;
SlaveModulo:=SlaveMaxPos-SlaveMinPos;&#xD;
SlaveCountMode:=ReadAxisSlavePParam.PosCount.CountMode;&#xD;
IF SlaveCountMode=_mcCountModeRotary THEN&#xD;
	// Axe en modulo&#xD;
	FBi_SyncMov.Direction:=_mcShortestWay;&#xD;
	IF 	SlaveMinPos&gt;=0 AND SlaveMaxPos&gt;=0 THEN&#xD;
		FBi_SyncMov.Position:=ABS(ModReal(Gen,SlaveModulo)); // Filtre la présence éventuelle de signe dans Gen&#xD;
	ELSIF&#xD;
		SlaveMinPos&lt;0 AND SlaveMaxPos&lt;0 THEN&#xD;
		FBi_SyncMov.Position:=-1*(ABS(ModReal(Gen,SlaveModulo))); // Filtre l'absence éventuelle de signe dans Gen&#xD;
		// Autre solution de filtrage : FBi_SyncMov.Position:=ModReal(Gen+SlaveModulo,SlaveModulo);&#xD;
	ELSE&#xD;
		FBi_SyncMov.Position:=ModReal(Gen,SlaveModulo);  // Pas de filtre : Gen négatif ou positif autorisé&#xD;
	END_IF;	&#xD;
ELSE&#xD;
	// Axe en mode linéaire&#xD;
	FBi_SyncMov.Direction:=_mcNoDirection;&#xD;
	IF (TypeOfCmd=Track AND IO.Flags.Synchronised) OR TypeOfCmd=CancelTrack THEN&#xD;
		// Polynôme de tracking terminé : synchronisation maître/esclave (following)&#xD;
		FBi_SyncMov.Position:=IO.Track.TrackPos;&#xD;
	ELSE&#xD;
		FBi_SyncMov.Position:=Gen; // Pas de filtre : Gen négatif ou positif autorisé&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*			T_InDone et T_OutDone				*&#xD;
*******************************************&#xD;
*)&#xD;
// Délai atteint après le début d'un mouvement polynômial ou d'un tracking&#xD;
TickSetT_In:=fTicksQCalc(IO.Move.SetT_In);&#xD;
IF Tick=TickSetT_In THEN&#xD;
	IF TypeOfCmd=PolyMvt THEN&#xD;
		IO.Move.T_InDone:=TRUE;&#xD;
	END_IF;&#xD;
	IF TypeOfCmd=Track THEN&#xD;
		IO.Track.T_InDone:=TRUE;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
// Délai atteint avant la fin d'un mouvement polynômial&#xD;
TickSetT_Out:=fTicksQCalc(IO.Move.SetT_Out);&#xD;
IF Tick=TickSetT_Out THEN&#xD;
	IO.Move.T_OutDone:=TRUE;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*	   Synthèse et messages d'erreurs		*&#xD;
*******************************************&#xD;
*)&#xD;
// Synthèse des erreurs&#xD;
IF FBi_SyncMov.Error OR FBi_SyncStop.Error OR FBi_ReadAxisMasterParam.Error OR FBi_ReadAxisSlaveParam.Error OR FBi_SyncMovVel.Error OR CamSettingError OR&#xD;
	IO.MC_Power.Error OR IO.MC_MoveJog.Error OR IO.MC_SetPosition.Error OR IO.MasterAxis.MFaultLvl.Active OR IO.MasterAxis.Status.ErrorStop OR&#xD;
	Axis.MFaultLvl.Active OR Axis.Status.ErrorStop OR ExternalError THEN&#xD;
	Error:=TRUE;&#xD;
	Phase:=-1;&#xD;
ELSE&#xD;
	Error:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
// Erreur : l'axe maître n'est pas en mode rotationnel&#xD;
IF (TypeOfCmd=Cam OR TypeOfCmd=WarmStart) THEN&#xD;
	IF FBi_ReadAxisMasterParam.Done AND NOT (ReadAxisMasterPParam.PosCount.CountMode=_mcCountModeRotary) THEN&#xD;
		CamSettingError:=TRUE;&#xD;
		CamSettingErrorType:='Master axis is not in rotary count mode';&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
// Erreur : le nombre de noeuds est supérieur au maximum autorisé&#xD;
IF NodesNb&gt;NodesNbMax THEN&#xD;
	CamSettingError:=TRUE;&#xD;
	CamSettingErrorType:='Too much nodes';&#xD;
END_IF;&#xD;
&#xD;
// Erreur : le nombre de profils est supérieur au maximum autorisé&#xD;
IF ProfilesNb&gt;ProfilesNbMax THEN&#xD;
	CamSettingError:=TRUE;&#xD;
	CamSettingErrorType:='Too much profiles';&#xD;
END_IF;&#xD;
&#xD;
// Erreur : une valeur maximale de modulo de l'axe maître a été franchie&#xD;
IF IO.MasterAxis.Scale.CountMode=_mcCountModeRotary THEN&#xD;
	FOR Loop:=0 TO NodesNb-1 DO&#xD;
		IF IO.Cam.Profile[CurrentProfile].Node[Loop].MasterAxisPos&gt;IO.MasterAxis.Scale.MaxPos OR&#xD;
			IO.Cam.Profile[CurrentProfile].Node[Loop].MasterAxisPos&lt;IO.MasterAxis.Scale.MinPos THEN&#xD;
			CamSettingError:=TRUE;&#xD;
			CamSettingErrorType:='Master MaxPos or MinPos overflow';&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
&#xD;
// Erreur : une valeur maximale de modulo de l'axe esclave a été franchie&#xD;
IF Axis.Scale.CountMode=_mcCountModeRotary THEN&#xD;
	FOR Loop:=0 TO NodesNb-1 DO&#xD;
		IF 	IO.Cam.Profile[CurrentProfile].Node[Loop].SlaveAxisPos+IO.Cam.SlaveOffset&gt;Axis.Scale.MaxPos OR&#xD;
			IO.Cam.Profile[CurrentProfile].Node[Loop].SlaveAxisPos+IO.Cam.SlaveOffset&lt;Axis.Scale.MinPos THEN&#xD;
			CamSettingError:=TRUE;&#xD;
			CamSettingErrorType:='Slave MaxPos or MinPos overflow';&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
&#xD;
// Erreur : une limite logicielle de l'axe maître a été franchie&#xD;
IF ReadAxisMasterPParam.Limit.SwLimitMode&lt;&gt;_mcNonSwLmt THEN&#xD;
	FOR Loop:=0 TO NodesNb-1 DO&#xD;
		IF 	IO.Cam.Profile[CurrentProfile].Node[Loop].MasterAxisPos&gt;ReadAxisMasterPParam.Limit.PosiSwLimit OR&#xD;
			IO.Cam.Profile[CurrentProfile].Node[Loop].MasterAxisPos&lt;ReadAxisMasterPParam.Limit.NegaSwLimit THEN&#xD;
			CamSettingError:=TRUE;&#xD;
			CamSettingErrorType:='Master software limit overflow';&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
&#xD;
// Erreur : une limite logicielle de l'axe esclave a été franchie&#xD;
IF ReadAxisSlavePParam.Limit.SwLimitMode&lt;&gt;_mcNonSwLmt THEN&#xD;
	FOR Loop:=0 TO NodesNb-1 DO&#xD;
		IF 	IO.Cam.Profile[CurrentProfile].Node[Loop].SlaveAxisPos&gt;ReadAxisSlavePParam.Limit.PosiSwLimit OR&#xD;
			IO.Cam.Profile[CurrentProfile].Node[Loop].SlaveAxisPos&lt;ReadAxisSlavePParam.Limit.NegaSwLimit THEN&#xD;
			CamSettingError:=TRUE;&#xD;
			CamSettingErrorType:='Slave software limit overflow';&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
&#xD;
// Messages d'erreur&#xD;
IF FBi_SyncMov.Error THEN&#xD;
	ErrorMsg:='Internal error : MC_SyncMoveAbsolute';&#xD;
ELSIF&#xD;
	FBi_SyncStop.Error THEN&#xD;
	ErrorMsg:='Internal error : MC_Stop';&#xD;
ELSIF&#xD;
	FBi_ReadAxisMasterParam.Error THEN&#xD;
	ErrorMsg:='Internal error : MC_ReadAxisParameter master';&#xD;
ELSIF&#xD;
	FBi_ReadAxisSlaveParam.Error THEN&#xD;
	ErrorMsg:='Internal error : MC_ReadAxisParameter slave';&#xD;
ELSIF&#xD;
	FBi_SyncMovVel.Error THEN&#xD;
	ErrorMsg:='Internal error : MC_SyncMoveVelocity';&#xD;
ELSIF&#xD;
	CamSettingError THEN&#xD;
	ErrorMsg:=CONCAT('Internal error : Cam setting error ',CamSettingErrorType);&#xD;
ELSIF&#xD;
	IO.MC_Power.Error THEN&#xD;
	ErrorMsg:='External error : MC_Power';&#xD;
ELSIF&#xD;
	IO.MC_MoveJog.Error THEN&#xD;
	ErrorMsg:='External error : MC_MoveJog';&#xD;
ELSIF&#xD;
	IO.MC_SetPosition.Error THEN&#xD;
	ErrorMsg:='External error : MC_SetPosition';&#xD;
ELSIF&#xD;
	IO.MasterAxis.MFaultLvl.Active OR IO.MasterAxis.Status.ErrorStop THEN&#xD;
	ErrorMsg:='External error : Master minor or major error';&#xD;
ELSIF&#xD;
	Axis.MFaultLvl.Active OR Axis.Status.ErrorStop THEN&#xD;
	ErrorMsg:='External error : Slave minor or major error';&#xD;
ELSIF&#xD;
	ExternalError THEN&#xD;
	ErrorMsg:='External error : External error';&#xD;
ELSE&#xD;
	ClearString(ErrorMsg);&#xD;
END_IF;&#xD;
	&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*						Monitoring						*&#xD;
*******************************************&#xD;
*)&#xD;
IO.Monitoring.PositioningCmd:=FBi_SyncMov.Position;&#xD;
IO.Monitoring.TypeOfCmd:=TypeOfCmd;&#xD;
IO.Monitoring.CurrentProfile:=CurrentProfile;		&#xD;
IO.Monitoring.CurrentSegment:=CurrentSegment;&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*				Fonctions internes					*&#xD;
*******************************************&#xD;
*)&#xD;
// Positionnement cyclique&#xD;
FBi_SyncMov(&#xD;
					Axis:=Axis, &#xD;
					BufferMode:=_mcAborting&#xD;
					);&#xD;
&#xD;
// Arrêt du positionnement cyclique&#xD;
FBi_SyncStop(&#xD;
					Axis:=Axis&#xD;
					);&#xD;
&#xD;
// Lecture des paramètres de l'axe maître&#xD;
FBi_ReadAxisMasterParam(&#xD;
					Axis:=IO.MasterAxis,&#xD;
					AxisParameter:=ReadAxisMasterPParam&#xD;
					);&#xD;
&#xD;
// Lecture des paramètres de l'axe esclave&#xD;
FBi_ReadAxisSlaveParam(&#xD;
					Axis:=Axis,&#xD;
					AxisParameter:=ReadAxisSlavePParam&#xD;
					);&#xD;
&#xD;
// MC_SyncMoveVelocity&#xD;
FBi_SyncMovVel(&#xD;
					Axis:=Axis&#xD;
					);&#xD;
&#xD;
&#xD;
(*&#xD;
*******************************************&#xD;
*				Fonctions externes					*&#xD;
*******************************************&#xD;
*)&#xD;
// MC_Power&#xD;
FBe_Power(&#xD;
					Axis:=Axis, &#xD;
					Enable:=IO.MC_Power.Enable, &#xD;
					Status=&gt;IO.MC_Power.Status, &#xD;
					Busy=&gt;IO.MC_Power.Busy, &#xD;
					Error=&gt;IO.MC_Power.Error, &#xD;
					ErrorID=&gt;IO.MC_Power.ErrorID&#xD;
					);&#xD;
&#xD;
// MC_MoveJog&#xD;
FBe_MovJog(&#xD;
					Axis:= Axis,&#xD;
					PositiveEnable:=IO.MC_MoveJog.PositiveEnable, &#xD;
					NegativeEnable:=IO.MC_MoveJog.NegativeEnable, &#xD;
					Velocity:=IO.MC_MoveJog.Velocity, &#xD;
					Acceleration:=IO.MC_MoveJog.Acceleration, &#xD;
					Deceleration:=IO.MC_MoveJog.Deceleration,&#xD;
					Busy=&gt;IO.MC_MoveJog.Busy, &#xD;
					CommandAborted=&gt;IO.MC_MoveJog.CommandAborted, &#xD;
					Error=&gt;IO.MC_MoveJog.Error, &#xD;
					ErrorID=&gt;IO.MC_MoveJog.ErrorID&#xD;
					);&#xD;
&#xD;
// MC_SetPosition&#xD;
FBe_SetPosition(&#xD;
					Axis:=Axis,&#xD;
					Execute:=IO.MC_SetPosition.Execute, &#xD;
					Position:=IO.MC_SetPosition.Position, &#xD;
					ReferenceType:=IO.MC_SetPosition.ReferenceType, &#xD;
					Relative:=IO.MC_SetPosition.Relative, &#xD;
					ExecutionMode:=IO.MC_SetPosition.ExecutionMode, &#xD;
					Done=&gt;IO.MC_SetPosition.Done, &#xD;
					Busy=&gt;IO.MC_SetPosition.Busy, &#xD;
					CommandAborted=&gt;IO.MC_SetPosition.CommandAborted, &#xD;
					Error=&gt;IO.MC_SetPosition.Error, &#xD;
					ErrorID=&gt;IO.MC_SetPosition.ErrorID&#xD;
					);&#xD;
&#xD;
// MC_Home&#xD;
FBe_Home(&#xD;
					Axis:=Axis,&#xD;
					Execute:=IO.MC_Home.Execute, &#xD;
					Done=&gt;IO.MC_Home.Done, &#xD;
					Busy=&gt;IO.MC_Home.Busy, &#xD;
					CommandAborted=&gt;IO.MC_Home.CommandAborted, &#xD;
					Error=&gt;IO.MC_Home.Error, &#xD;
					ErrorID=&gt;IO.MC_Home.ErrorID&#xD;
					);&#xD;
&#xD;
// MC_GearIn&#xD;
FBe_GearIn(&#xD;
					Master:=IO.MC_GearIn.Master, &#xD;
					Slave:=Axis, &#xD;
					Execute:=IO.MC_GearIn.Execute, &#xD;
					RatioNumerator:=IO.MC_GearIn.RatioNumerator, &#xD;
					RatioDenominator:=IO.MC_GearIn.RatioDenominator, &#xD;
					ReferenceType:=IO.MC_GearIn.ReferenceType, &#xD;
					Acceleration:=IO.MC_GearIn.Acceleration, &#xD;
					Deceleration:=IO.MC_GearIn.Deceleration, &#xD;
					Jerk:=IO.MC_GearIn.Jerk, &#xD;
					BufferMode:=IO.MC_GearIn.BufferMode, &#xD;
					InGear=&gt;IO.MC_GearIn.InGear, &#xD;
					Busy=&gt;IO.MC_GearIn.Busy, &#xD;
					Active=&gt;IO.MC_GearIn.Active, &#xD;
					CommandAborted=&gt;IO.MC_GearIn.CommandAborted, &#xD;
					Error=&gt;IO.MC_GearIn.Error, &#xD;
					ErrorID=&gt;IO.MC_GearIn.ErrorID&#xD;
					);&#xD;
&#xD;
// MC_GearOut&#xD;
FBe_GearOut(&#xD;
					Slave:=Axis, &#xD;
					Execute:=IO.MC_GearOut.Execute, &#xD;
					Deceleration:=IO.MC_GearOut.Deceleration, &#xD;
					Jerk:=IO.MC_GearOut.Jerk, &#xD;
					OutMode:=IO.MC_GearOut.OutMode,&#xD;
					Done=&gt;IO.MC_GearOut.Done, &#xD;
					Busy=&gt;IO.MC_GearOut.Busy, &#xD;
					CommandAborted=&gt;IO.MC_GearOut.CommandAborted, &#xD;
					Error=&gt;IO.MC_GearOut.Error, &#xD;
					ErrorID=&gt;IO.MC_GearOut.ErrorID&#xD;
					);&#xD;
&#xD;
// MC_SetTorqueLimit&#xD;
FBe_SetTorqueLimit(&#xD;
					Axis:=Axis, &#xD;
					Enable:=IO.MC_SetTorqueLimit.Enable, &#xD;
					PositiveEnable:=IO.MC_SetTorqueLimit.PositiveEnable, &#xD;
					PositiveValue:=IO.MC_SetTorqueLimit.PositiveValue, &#xD;
					NegativeEnable:=IO.MC_SetTorqueLimit.NegativeEnable, &#xD;
					NegativeValue:=IO.MC_SetTorqueLimit.NegativeValue, &#xD;
					Enabled=&gt;IO.MC_SetTorqueLimit.Enabled, &#xD;
					Busy=&gt;IO.MC_SetTorqueLimit.Busy, &#xD;
					Error=&gt;IO.MC_SetTorqueLimit.Error, &#xD;
					ErrorID=&gt;IO.MC_SetTorqueLimit.ErrorID&#xD;
					);&#xD;
&#xD;
// MC_SetOverride&#xD;
FBe_SetOverride(&#xD;
					Axis:=Axis, &#xD;
					Enable:=IO.MC_SetOverride.Enable, &#xD;
					VelFactor:=IO.MC_SetOverride.VelFactor, &#xD;
					AccFactor:=IO.MC_SetOverride.AccFactor, &#xD;
					JerkFactor:=IO.MC_SetOverride.JerkFactor, &#xD;
					Enabled=&gt;IO.MC_SetOverride.Enabled, &#xD;
					Busy=&gt;IO.MC_SetOverride.Busy, &#xD;
					Error=&gt;IO.MC_SetOverride.Busy, &#xD;
					ErrorID=&gt;IO.MC_SetOverride.ErrorID&#xD;
					);&#xD;
</Text></StructuredTextModel>